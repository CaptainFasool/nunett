#!/bin/bash
#
## @file        nunet
## @author      Dagim Sisay <dagim@nunet.io>
## @licence     AGPL

# NuNet CLI - Device Management Service

GOOD_C='\033[32m'   # GREEN
INFO_C='\033[33m' # YELLOW
BAD_C='\033[31m'    # RED
NORMAL_C='\033[0m'

SELF_NAME=$(basename $0)

DMS_HOST=localhost
DMS_PORT=9999
ADAPTER_PORT=60777

usage() {
    echo -e "Usage: $SELF_NAME [OPTIONS] COMMAND\n"
    echo -e "Command line interface for the NuNet Device Management Service.\n"
    echo "Options:"
    echo "    -v, --verbose    Verbose output"
    echo -e "    -p, --pretty     Prettified JSON output\n"
    echo "Commands:"
    echo "  available     Display available resources"
    echo "  wallet        Get Current Wallet Address"
    echo "  onboard       Onboard the device to NuNet"
    echo "  info          Get info about currently onboarded machine"
    echo "  onboard-gpu   Install NVIDIA GPU driver and Container Runtime"
    echo "  onboard-ml    Prepare the system for Machine Learning with GPU"
    echo "  shell         Send commands and receive answers to a vm instance via DMS"
    echo -e "  peer          Interact with currently visible peers\n"
    echo "For more information, visit https://gitlab.com/nunet/device-management-service/-/wikis/home"
    exit
}

available_usage() {
    echo -e "Usage: $SELF_NAME available [OPTIONS]\n"
    echo -e "Command line interface for the NuNet Device Management Service.\n"
    echo "Options:"
    echo "    -v, --verbose    Verbose output"
    echo -e "    -p, --pretty     Prettified JSON output\n"
    echo "For more information, visit https://gitlab.com/nunet/device-management-service/-/wikis/home"
    exit
}

wallet_usage() {
    echo -e "Usage: $SELF_NAME wallet COMMAND [OPTIONS] \n"
    echo -e "Manage blockchain wallet.\n"
    echo "Options:"
    echo "    -v, --verbose    Verbose output"
    echo -e "    -p, --pretty     Prettified JSON output\n"
    echo "Commands:"
    echo -e "  new         Create a new wallet address. Returns public and private keys.\n"
    echo "For more information, visit https://gitlab.com/nunet/device-management-service/-/wikis/home"
    exit
}

onboard_usage() {
    echo -e "Usage: $SELF_NAME {-mcna} [-Cvp]\n"
    echo -e "Onboard the current machine to the NuNet platform.\n"
    echo "Options:"
    echo "    -m, --memory           Amount of memory in Megabytes"
    echo "    -c, --cpu              Amount of CPU in Megahertz"
    echo "    -n, --nunet-channel    NuNet channel to onboard the machine to:"
    echo "                             OPTIONS"
    echo "                               'nunet-test' - Development branch for Community Testers"
    echo "                               'nunet-staging' - Staging branch for Community Testers"
    echo "    -a, --address          Wallet Address (Public Key)"
    echo "    -C, --cardano          Allow deployment of a Cardano Node"
    echo "    -v, --verbose          Verbose output"
    echo -e "    -p, --pretty           Prettified JSON output\n"
    echo "For more information, visit https://gitlab.com/nunet/device-management-service/-/wikis/home"
    exit
}

peer_usage() {
    echo -e "Usage: $SELF_NAME peer COMMAND [OPTIONS] \n"
    echo -e "Interact with connected peers.\n"
    echo "Commands:"
    echo -e "  list         List visible peers.\n"
    echo "For more information, visit https://gitlab.com/nunet/device-management-service/-/wikis/home"
    exit
}

available() {
    if [[ ${#@} -ge 3 ]] ; then
        printf "\n${BAD_C}Wrong number of arguments to 'available' command${NORMAL_C}\n"
        exit
    else
        avargs=($@)
        for avarg in "${avargs[@]}"; do
            case $avarg in
                "-p" | "--pretty")
                    NPRETTY_OUT=1
                    ;;
                "-v" | "--verbose")
                    NVERBOSE_OUT=1
                    ;;
                *)
                    printf "${BAD_C}Bad argument \"$avarg\" for 'available' Command. ${NORMAL_C}\n"
                    exit
                    ;;
            esac
        done
    fi

    N_C_OUT=$(curl -s $DMS_HOST:$DMS_PORT/api/v1/onboarding/provisioned)
    if [[ $NPRETTY_OUT -eq 1 ]] ; then
        echo $N_C_OUT | jq
    else
        echo $N_C_OUT
    fi
}

wallet() {
    if [[ ${#@} -ge 4 || ${#@} -lt 1 ]] ; then
        wallet_usage
    else
        avargs=($@)
        for avarg in "${avargs[@]}"; do
            case $avarg in
                "-p" | "--pretty")
                    NPRETTY_OUT=1
                    ;;
                "-v" | "--verbose")
                    NVERBOSE_OUT=1
                    ;;
                "new")
                    N_CREATE_WALLET=$(curl -s $DMS_HOST:$DMS_PORT/api/v1/onboarding/address/new)
                    ;;
                *)
                    printf "${BAD_C}Bad argument \"$avarg\" for 'wallet' Command. ${NORMAL_C}\n\n"
                    wallet_usage
                    exit
                    ;;
            esac
        done
    fi

    if [[ N_CREATE_WALLET == "" ]] ; then
        printf "${BAD_C}Not yet implemented. Only 'wallet new' at this time.${NORMAL_C}\n"
        wallet_usage
    else
        if [[ $NPRETTY_OUT -eq 1 ]] ; then
            echo $N_CREATE_WALLET | jq
        else
            echo $N_CREATE_WALLET
        fi
    fi
}

onboard() {
    N_ONBOARD_OPTS=$(getopt -a -n nunet-onboard -o m:c:n:a:Cvp: --long memory:,cpu:,nunet-channel:,address:,cardano,verbose,pretty -- "$@")
    eval set -- "$N_ONBOARD_OPTS"

    N_ONBOARD_CARDANO=false

    if [[ ${#@} -le 1 ]] ; then
        onboard_usage
    fi

    while :
        do
            case "$1" in
                -m | --memory)        N_ONBOARD_MEM="$2"  ; shift 2 ;;
                -c | --cpu)           N_ONBOARD_CPU="$2"  ; shift 2 ;;
                -n | --nunet-channel) N_ONBOARD_CHAN="$2" ; shift 2 ;;
                -a | --address)       N_ONBOARD_ADD="$2"  ; shift 2 ;;
                -C | --cardano)       N_ONBOARD_CARDANO=true ; shift ;;
                -v | --verbose)       N_ONBOARD_VERBOSE=1 ; shift ;;
                -p | --pretty)        N_ONBOARD_PRETTY=1  ; shift ;;
                --) shift; break ;;
                *) echo "Unexpected option: $1."
                    onboard_usage ;;
            esac
    done

    # validation
    [[ -z $N_ONBOARD_CPU ]] && printf "${BAD_C}Error: -c | --cpu must be specified.${NORMAL_C}\n" && onboard_usage
    [[ -z $N_ONBOARD_MEM ]] && printf "${BAD_C}Error: -m | --memory must be specified.${NORMAL_C}\n" && onboard_usage
    [[ -z $N_ONBOARD_CHAN ]] && printf "${BAD_C}Error: -n | --nunet-channel must be specified.${NORMAL_C}\n" && onboard_usage
    [[ -z $N_ONBOARD_ADD ]] && printf "${BAD_C}Error: -a | --address must be specified.${NORMAL_C}\n" && onboard_usage

    N_AVAILABLE_RES=$(curl -s $DMS_HOST:$DMS_PORT/api/v1/onboarding/provisioned)
    N_AVAILABLE_MEM=$(echo $N_AVAILABLE_RES | jq ".memory")
    N_AVAILABLE_CPU=$(echo $N_AVAILABLE_RES | jq ".cpu")
    N_AVAILABLE_CPU=$(printf "%.0f" $(echo $N_AVAILABLE_CPU | bc)) # rounding in case of decimal values cpu freq such as cloud
    if [[ $N_ONBOARD_MEM -gt $((N_AVAILABLE_MEM*9/10)) || $N_ONBOARD_MEM -lt $((N_AVAILABLE_MEM/10)) ]] ; then
        printf "${BAD_C}Memory should be between 10%% and 90%% of the available memory ($((N_AVAILABLE_MEM/10)) and $((N_AVAILABLE_MEM*9/10))) ${NORMAL_C}\n"
        printf "${INFO_C}Check available resources with 'nunet available --pretty'${NORMAL_C}\n"
        exit
    elif [[ $N_ONBOARD_CPU -gt $((N_AVAILABLE_CPU*9/10)) || $N_ONBOARD_CPU -lt $((N_AVAILABLE_CPU/10)) ]] ; then
        printf "${BAD_C}CPU should be between 10%% and 90%% of the available CPU ($((N_AVAILABLE_CPU/10)) and $((N_AVAILABLE_CPU*9/10))) ${NORMAL_C}\n"
        printf "${INFO_C}Check available resources with 'nunet available --pretty'${NORMAL_C}\n"
        exit
    elif [[ "$N_ONBOARD_CHAN" != "nunet-test" && "$N_ONBOARD_CHAN" != "nunet-staging" && "$N_ONBOARD_CHAN" != "nunet-team" && "$N_ONBOARD_CHAN" != "nunet-edge" ]] ; then
        printf "${BAD_C}NuNet Channel should be 'nunet-test' or 'nunet-staging' not $N_ONBOARD_CHAN ${NORMAL_C}\n"
        exit
    elif [[ "$N_ONBOARD_CHAN" == "nunet-team" || "$N_ONBOARD_CHAN" == "nunet-edge" ]] ; then
        while true; do
            read -p "Are you sure you want to join $N_ONBOARD_CHAN?? (yes/no) " chan_resp
            case $chan_resp in
                yes ) echo "Proceeding with onboarding to $N_ONBOARD_CHAN channel";
                    break;;
                no) echo "Exiting...";
                    exit;;
                *) echo "Only 'yes' or 'no' please";;
            esac
        done
    else
        N_ONBOARD_RESPONSE=$(curl -s -X POST -H "Content-Type: application/json" \
            -d "{\"memory\": $N_ONBOARD_MEM, \"cpu\": $N_ONBOARD_CPU, \
            \"channel\":\"$N_ONBOARD_CHAN\", \"payment_addr\": \"$N_ONBOARD_ADD\", \
            \"cardano\": $N_ONBOARD_CARDANO}" \
            $DMS_HOST:$DMS_PORT/api/v1/onboarding/onboard)
        # check if error
        N_ONBOARD_ERR_MSG=$(echo $N_ONBOARD_RESPONSE | jq '. | select(.error != null) | .error')
        if [[ ! -z $N_ONBOARD_ERR_MSG ]] ; then
            printf "${BAD_C}Error: $N_ONBOARD_ERR_MSG ${NORMAL_C}\n"
        else
            printf "${GOOD_C}Successfully Onboarded.${NORMAL_C}\n"
            [[ -z $N_ONBOARD_PRETTY ]] && echo $N_ONBOARD_RESPONSE || echo $N_ONBOARD_RESPONSE | jq
        fi
    fi

}

info() {
    N_INFO=$(curl -s $DMS_HOST:$DMS_PORT/api/v1/onboarding/metadata)
    N_INFO_ERR_MSG=$(echo $N_INFO | jq '. | select(.error != null) | .error')
    if [[ ! -z $N_INFO_ERR_MSG ]] ; then
        printf "${BAD_C}Error: $N_INFO_ERR_MSG ${NORMAL_C}\n"
    else
        echo $N_INFO | jq
    fi
}

peer() {
    check_adapter_run
    if [[ ${#@} -ge 2 || ${#@} -lt 1 ]] ; then
        peer_usage
    else
        avargs=($@)
        for avarg in "${avargs[@]}"; do
            case $avarg in
                "list")
                    N_LIST_PEERS=$(curl -s $DMS_HOST:$DMS_PORT/api/v1/peers)
                    ;;
                *)
                    printf "${BAD_C}Bad argument \"$avarg\" for 'peer' Command. ${NORMAL_C}\n\n"
                    peer_usage
                    exit
                    ;;
            esac
        done
    fi

    N_LIST_PEERS_ERR_MSG=$(echo $N_LIST_PEERS | jq '. | select(.error != null) | .error')
    if [[ ! -z $N_LIST_PEERS_ERR_MSG ]] ; then
        printf "${BAD_C}Error: $N_LIST_PEERS_ERR_MSG ${NORMAL_C}\n"
    elif [[ N_LIST_PEERS == "" ]] ; then
        printf "${BAD_C}No peers available. Please try again in a few minutes.${NORMAL_C}\n"
    else
        echo $N_LIST_PEERS | jq --raw-output '["Node-ID", "Public-Key"], ["-------", "----------"], (.[] | [.peer_info.nodeID, .peer_info.public_key]) | @tsv' | column -t
    fi
}

check_dms_run() {
    N_CHECK_DMS=$(ss -tnlp 2>/dev/null | grep ":$DMS_PORT")
    if [[ ! $? -eq 0 ]] ; then
        printf "${BAD_C}Looks like NuNet DMS is not running."
        printf "Please check with ${INFO_C}'systemctl status nunet-dms.service'${NORMAL_C}\n"
        exit
    fi
}

check_adapter_run() {
    N_CHECK_ADAPTER=$(ss -tnlp 2>/dev/null | grep ":$ADAPTER_PORT")
    if [[ ! $? -eq 0 ]] ; then
        printf "${BAD_C}Looks like NuNet Adapter is not running."
        printf "Please check with ${INFO_C}'docker ps -a | grep adapter'${NORMAL_C}\n"
        exit
    fi
}


secure_boot_check() {
    #Check for Secure Boot before proceeding with GPU driver installation, alert user with necessary information if yes.
    sudo apt install -y mokutil
    secure_boot_check="$(mokutil --sb-state | grep enabled)"
    secure_boot="enabled"
    if grep -q "$secure_boot" <<<"$secure_boot_check"; then
        printf "${INFO_C}************Important Note!!!************\n"
        printf "Your system has UEFI Secure Boot enabled.\n"
        printf "*****************************************\n"
        printf "a. NVIDIA GPU Driver installation will require you to enroll a password(confirmed twice) as a machine owner key(MOK).\n"
        printf "b. Reboot your system after finishing the onboarding procedure.\n"
        printf "c. Make sure you select “Enroll MOK” before Linux boots the next time.\n"
        printf "d. Remember to enter the same password as the MOK.\n"
        printf "Driver installation will fail without the above steps.\n"
        printf "In case you miss any of these steps, you can also manually repeat the process later with the command “sudo update-secureboot-policy --enroll-key” and reboot.\n"
        printf "Ensure steps a, b, c and d.\n"
        printf "Resuming installation in a minute...${NORMAL_C}\n"
        sleep 60
    fi
}


## Install NVIDIA GPU Drivers and Container Runtime
onboard-gpu() {
    nvidia="$(lspci | grep 'VGA compatible controller: NVIDIA' | awk '{print $5}')" # a variable with value "NVIDIA"
    gpu="$(lspci | grep 'VGA compatible controller: NVIDIA' | awk '{print $8 " " $9 " " $10 " " $11}')" # tries to fetch the gpu name
    gpu_driver_version="$(nvidia-smi | grep Driver | awk '{print "NVIDIA " $4 " " $5 " " $6}')" # the gpu driver version
    gpu_driver_var="$(nvidia-smi | grep Driver | awk '{print $4}')" # a variable with value "Driver"
    linux_distro=$(grep -Po "(?<=^ID=).+" /etc/os-release | sed 's/"//g') # we add support for specific linux distributions through this variable.
    # CHECK IF THERE IS NVIDIA GPU
    if [ -n "$nvidia" ]; then
        printf "${GOOD_C}$nvidia $gpu GPU device found! ${NORMAL_C}\n"
        # IF gpu_driver_var IS not EMPTY WE WILL SKIP DRIVER AND Install container runtime
        if [ -n "$gpu_driver_var" ]; then #IF $gpu_driver_var is not empty
            printf "${INFO_C}$gpu_driver_version is already installed. Skipping installation of driver.${NORMAL_C}\n"
        else
            secure_boot_check
            printf "${INFO_C}-----Starting NVIDIA GPU Driver Installation-----${NORMAL_C}\n"
            if [[ $linux_distro = "ubuntu" ]]; then
                sudo apt update && sudo apt install -y ubuntu-drivers-common #package required for below command
                sudo ubuntu-drivers install               #autoinstall is deprecated
            elif [[ $linux_distro = "kali" ]]; then
                sudo apt update && sudo apt install -y nvidia-driver
            else
                printf "${INFO_C}Currently, only Ubuntu and Kali Linux Distributions are supported. But we will definitely add support for more distros in future.${NORMAL_C}\n"
            fi
            gpu_driver_var="$(nvidia-smi | grep Driver | awk '{print $4}')"
            gpu_driver_version="$(nvidia-smi | grep Driver | awk '{print "NVIDIA " $4 " " $5 " " $6}')"
            if [[ $gpu_driver_var = "Driver" ]]; then
                printf "${GOOD_C}-----NVIDIA GPU Driver $gpu_driver_version Installed-----${NORMAL_C}\n"
            else
                printf "${BAD_C}-----NVIDIA GPU Driver Still Not Found. Please Retry-----${NORMAL_C}\n"
            fi
        fi

        printf "${INFO_C}-----Starting NVIDIA Container Runtime Installation-----${NORMAL_C}\n"
        curl -s -L https://nvidia.github.io/nvidia-container-runtime/gpgkey | sudo apt-key add -
        distribution=$(
            . /etc/os-release
            echo $ID$VERSION_ID
        )
        curl -s -L https://nvidia.github.io/nvidia-container-runtime/$distribution/nvidia-container-runtime.list | sudo tee /etc/apt/sources.list.d/nvidia-container-runtime.list
        sudo apt update
        sudo apt install -y nvidia-container-runtime

        sudo systemctl restart docker
        printf "${GOOD_C}-----NVIDIA Container Runtime Installed-----${NORMAL_C}\n"
    else
        # IF THERE IS NO NVIDIA GPU THE nvidia VARIABLE WILL BE EMPTY SO WE REPORT MISSING GPU
        printf "${INFO_C}This machine does not have an NVIDIA GPU. Skipping GPU Driver and Container Runtime Installation.${NORMAL_C}\n"    
    fi
}

# Onboarding for ML jobs
onboard-ml()
{
    sudo docker pull registry.gitlab.com/nunet/ml-on-gpu/ml-on-gpu-service/develop/tensorflow
    sudo docker pull registry.gitlab.com/nunet/ml-on-gpu/ml-on-gpu-service/develop/pytorch
}

## shell websocket connection  

shell(){
    # echo "to install on ubuntu run the following:"
    # echo "sudo wget -qO /usr/local/bin/websocat https://github.com/vi/websocat/releases/latest/download/websocat.x86_64-unknown-linux-musl"
    if [[ "$1" = "--node-id" &&  $# -eq 2 ]]; then
        websocat ws://127.0.0.1:9999/api/v1/peers/ws?nodeID=$2
    else
        echo "Please enter a --node-id <the-node-id>"
    fi
}

cmds=("available" "wallet" "onboard" "info" "peer" "onboard-gpu" "onboard-ml" "shell")

if [ $# -eq  0 ] ; then
    usage
else
    in_args=($@)
    arg=$1
    argargs=("${in_args[@]:1}")
    cmd_valid=0
    for cmd in "${cmds[@]}"; do
        if [[ $arg == $cmd ]]; then
            cmd_valid=1
            break
        fi
    done

    if [[ $cmd_valid -eq 0 ]] ; then
        printf "${BAD_C}Error: Command \"$arg\" not found.${NORMAL_C}\n"
        usage
    else
        check_dms_run
        $cmd ${argargs[@]}
    fi

fi
